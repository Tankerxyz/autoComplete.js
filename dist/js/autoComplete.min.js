(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.autoComplete = factory());
}(this, (function () { 'use strict';

	// Gets the user's input value
	const getSearchInput = () => document.querySelector("#autoComplete"); // Creats the results list HTML tag


	const createResultsList = listContainer => {
	  const list = document.createElement("ul");
	  list.setAttribute("class", "autoComplete_results_list");
	  listContainer.appendChild(list);
	}; // Creates results list container


	const createResultsListContainer = () => {
	  const listContainer = document.createElement("div");
	  listContainer.setAttribute("class", "autoComplete_results_list_container");
	  getSearchInput().insertAdjacentElement("afterend", listContainer);
	  createResultsList(listContainer);
	};

	createResultsListContainer(); // Adding matching results to the list

	const addResultsToList = (results, cleanResults, dataAttribute) => {
	  let resultState;
	  const resultsList = document.querySelector(".autoComplete_results_list");
	  results.forEach((event, record) => {
	    const result = document.createElement("li");
	    result.setAttribute(`data-${dataAttribute.tag}`, dataAttribute.value || cleanResults[record]);

	    if (results.length === 1) {
	      resultState = "autoComplete_result autoComplete_single_result";
	    } else {
	      resultState = "autoComplete_result";
	    }

	    result.setAttribute("id", cleanResults[record]);
	    result.setAttribute("class", resultState);
	    result.innerHTML = results[record];
	    resultsList.appendChild(result);
	  });
	}; // Toggle event for search input
	// showing & hidding results list onfocus / blur


	["focus", "blur"].forEach(eventType => {
	  const result = document.querySelector(".autoComplete_results_list");
	  getSearchInput().addEventListener(eventType, () => {
	    if (eventType === "blur") {
	      result.style = "opacity: 0; visibility: hidden;";
	    } else {
	      result.style = "opacity: 1; visibility: visible;";
	    }
	  });
	}); // Clears user input

	const clearInput = () => getSearchInput().value = ""; // Clears the list of results


	const clearResults = () => {
	  const resultsList = document.querySelector(".autoComplete_results_list");
	  resultsList.innerHTML = "";
	}; // Gets user selection


	const getSelection = (value, maxLength) => {
	  const results = document.querySelectorAll(".autoComplete_result");
	  results.forEach(selection => {
	    selection.addEventListener("click", event => {
	      // value(event.target.closest(".autoComplete_result"));
	      value(event.target.closest(".autoComplete_result")); // Clear Input after selection is made

	      clearInput(); //Clear Results after selection is made

	      clearResults(); // Set placeholder with the selected value
	      // after checking the value length and validate it

	      getSearchInput().setAttribute("placeholder", `${event.target.closest(".autoComplete_result").id.length > maxLength ? event.target.closest(".autoComplete_result").id.slice(0, maxLength) + "..." : event.target.closest(".autoComplete_result").id}`);
	    });
	  });
	}; // Error message render to UI


	const error = error => {
	  document.querySelector("body").innerHTML = `
		<div class="autoComplete_error">
			<div class="autoComplete_message">${error}</div>
		</div>
	`;
	};

	const renderResults = {
	  getSearchInput,
	  addResultsToList,
	  getSelection,
	  clearInput,
	  clearResults,
	  error
	};

	class autoComplete {
	  isDataSrcValid(dataSrc) {
	    if (Array.isArray(dataSrc)) {
	      return true;
	    } else if (dataSrc instanceof Promise) {
	      return true;
	    } else if (typeof dataSrc === 'function') {
	      return true;
	    } else {
	      return false;
	    }
	  }

	  async getDataSrc(input) {
	    if (Array.isArray(this.dataSrc)) {
	      return this.dataSrc;
	    } else if (typeof this.dataSrc === 'function') {
	      return await this.dataSrc(input);
	    }
	  }

	  constructor(config) {
	    // Source of data list
	    this.dataSrc = config.dataSrc; // Placeholder text

	    this.placeHolder = String(config.placeHolder) ? config.placeHolder : false; // Maximum Placeholder text length

	    this.placeHolderLength = Number(config.placeHolderLength) ? config.placeHolderLength : Infinity; // Maximum number of results to show

	    this.maxResults = Number(config.maxResults) ? config.maxResults : 10; // Highlighting matching results

	    this.highlight = typeof config.highlight === "boolean" ? config.highlight : true; // Assign data attribute tag & value if set in object

	    this.dataAttribute = config.dataAttribute === Object ? {
	      tag: config.dataAttribute.tag,
	      value: config.dataAttribute.value
	    } : {
	      tag: "autocomplete",
	      value: ""
	    }; // Action function on result selection

	    this.onSelection = typeof config.onSelection === "function" ? config.onSelection : renderResults.error("<strong>Error</strong>, <strong>onSelection</strong> value is not a <strong>Function</string>."); // Starts the app Enigne

	    this.init();
	  } // Search common characters within record


	  search(query, record) {
	    // Search query string sanitized & normalized
	    query = query.replace(/ /g, "").toLowerCase(); // Array of matching characters

	    let match = []; // Query character position based on success

	    let searchPosition = 0; // Iterate over record characters

	    for (let number = 0; number < record.length; number++) {
	      // Holds current record character
	      let recordChar = record[number]; // Matching case

	      if (searchPosition < query.length && recordChar.toLowerCase() === query[searchPosition]) {
	        if (this.highlight) {
	          // Highlight matching character
	          recordChar = "<span class=\"autoComplete_highlighted_result\">" + recordChar + "</span>"; // Increment search position

	          searchPosition++;
	        } else {

	          searchPosition++;
	        }
	      } // Adds matching character to the matching list


	      match.push(recordChar);
	    } // Non-Matching case


	    if (searchPosition !== query.length) {
	      return "";
	    } // Return the joined match


	    return match.join("");
	  } // List all matching results


	  listMatchedResults() {
	    return new Promise(res => {
	      // Final highlighted results list of array
	      this.resList = []; // Final clean results list of array

	      this.cleanResList = []; // Holds the input search value

	      let inputValue = renderResults.getSearchInput().value;

	      try {
	        // Checks input matches in data source
	        this.getDataSrc().then(dataSrc => {
	          dataSrc.filter(record => {
	            const match = this.search(inputValue, record);

	            if (match) {
	              this.resList.push(match);
	              this.cleanResList.push(record);
	            }
	          }); // Rendering matching results to the UI list

	          res(renderResults.addResultsToList(this.resList.slice(0, this.maxResults), this.cleanResList.slice(0, this.maxResults), this.dataAttribute));
	        });
	      } catch (error) {
	        renderResults.error(error);
	      }
	    });
	  } // Checks user's input search value validity


	  searchInputValidation(selector) {
	    // Input field handler fires an event onKeyup action
	    selector.addEventListener("keyup", async () => {
	      // event.preventDefault();
	      // Check if input is not empty or just have space before triggering the app
	      if (selector.value.length > 0 && selector.value !== " ") {
	        // clear results list
	        renderResults.clearResults(); // List matching results

	        this.listMatchedResults().then(() => {
	          // Gets user's selection
	          renderResults.getSelection(this.onSelection, this.placeHolderLength);
	        });
	      } else {
	        // clears all results list
	        renderResults.clearResults();
	      }
	    });
	  } // Placeholder setting function


	  setPlaceHolder() {
	    if (this.placeHolder) {
	      renderResults.getSearchInput().setAttribute("placeholder", this.placeHolder);
	    }
	  } // Starts the app Enigne


	  init() {
	    try {
	      // If the data source is valid run the app else error
	      if (this.isDataSrcValid(this.dataSrc)) {
	        this.setPlaceHolder();
	        this.searchInputValidation(renderResults.getSearchInput());
	      }
	    } catch (error) {
	      console.log(error);
	      renderResults.error("<strong>error</strong>, autoComplete <strong>engine</strong> is not <strong>starting</strong>...");
	    }
	  }

	}

	return autoComplete;

})));
